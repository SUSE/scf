#!/bin/bash

ROOT=`readlink -f "$( cd "$( dirname "${BASH_SOURCE[0]}" )" && pwd )/../../../"`

SILENT=
case "$1" in
  -s|--silent)
    SILENT=1 ;;
esac

. "${ROOT}/opt/hcf/bin/common.sh"

# Initialize colors
set_colors

# Get all possible roles from the role manifest
load_all_roles

# Calculate the length of the first column for the
# table we're going to display later on
col_len=$(echo ${role_names[@]} | awk 'BEGIN { RS="[ \t\n]" } { print length($0); }' | sort -nr | head -n1)

# Define the format of a row
rowfmt="%${col_len}b%b%12b%b%7b%b%11b${txtrst}%11b\n"
#       │           │ │   │ │  │ │   │        │
#       │           │ │   │ │  │ │   │        └──────────────────────────────┐
#       │           │ │   │ │  │ │   └──────────────────────────┐            │
#       │           │ │   │ │  │ └───────────────────┐          │            │
#       │           │ │   │ │  └──────────────┐      │          │            │
#       │    ┌──────┘ │   │ └──────────┐      │      │          │            │
# ┌─────┘    │      ┌─┘   └─────┐      │      │      │          │            │
# <role name><COLOR><containers><COLOR><monit><COLOR><processes><COLOR RESET><memusage>

if [ -z "${SILENT}" ]; then
  # Print a table header
  printf $rowfmt "Role" "" "Containers" "" "Monit" "" "Processes" "Usage"
  # Print  a line after the header (41 is the fixed length of all but the first columns)
  printf '=%.0s' $(seq 1 $(($col_len+41)))
  printf '\n'
fi

# Print the status of a bosh job
function status_job_bosh() {
  local role="${1}"
  local containers=( $(docker ps -q --filter label=role=${role}) )
  if [[ "${#containers[@]}" == 0 ]]; then
    # No containers running
    if [[ -n "${SILENT}" ]]; then
      exit 1
    fi
    printf ${rowfmt} ${role} ${bldred} ${#containers[@]} ${txtgrn} "n/a" ${txtgrn} "n/a" "n/a"
    return
  fi

  processes=( $(list_processes_for_role ${role}) )
  # We only check the first container for monit and processes
  local monit_data=$(docker exec ${containers[0]} bash -c 'if [ -f /etc/secrets/monit-password ]; then MONIT_PASSWORD=`cat /etc/secrets/monit-password`; fi; curl -s -u admin:${MONIT_PASSWORD} http://127.0.0.1:2289/_status' || true)
  if [[ -z "${monit_data}" ]]; then
    # monit is down
    if [[ -n "${SILENT}" ]]; then
      exit 1
    fi
    printf ${rowfmt} ${role} ${txtgrn} ${#containers[@]} ${bldred} "down" ${bldred} "0/${#processes[@]}"  "n/a"
    return
  fi

  local ok_processes=0
  local process
  for process in ${processes[@]}; do
    # Look for the status "Running" on the line following a process definition
    local process_status=$(echo -e "${monit_data}" | grep -A 1 "Process '${process}'" | tail -n1 | awk '{print $2}')

    # Increase the number of processes that are working ok
    if [[ "${process_status}" == "Running" ]] || [[ "${process_status}" == "running" ]]; then
      ok_processes=$(($ok_processes + 1))
    fi
  done

  if [[ -n "${SILENT}" ]]; then
    if [[ "${ok_processes}" != "${#processes[@]}" ]]; then
      exit 1
    fi
    return
  fi

  local processes_color
  case ${ok_processes} in
    0)                processes_color=${bldred};;
    ${#processes[@]}) processes_color=${bldgrn};;
    *)                processes_color=${bldpur};;
  esac

  mem_used=$(mem_used_from_container ${containers[0]})
  printf ${rowfmt} ${role} ${txtgrn} ${#containers[@]} ${txtgrn} "up" ${processes_color} "${ok_processes}/${#processes[@]}" ${mem_used}
}

function mem_used_from_container {
    local container=${1}
    long_id=$(docker inspect ${container} | jq --raw-output '.[0].Id')
    memory_file=/sys/fs/cgroup/memory/docker/${long_id}/memory.usage_in_bytes
    if [[ ! -f ${memory_file} ]] ; then
      echo "n/a"
    else
      numfmt --to-unit=$((1024*1024)) --suffix=MB $(cat ${memory_file})
    fi
}

# Print the status of a docker job
function status_job_docker() {
  local role="${1}"
  local containers=( $(docker ps -q --filter label=role=${role}) )
  local containers_color=${bldred}
  if [[ ${#containers[@]} -gt 0 ]]; then
    containers_color=${bldgrn}
  fi

  if [[ -n "${SILENT}" ]]; then
    if [[ ${#containers[@]} -le 0 ]]; then
      exit 1
    fi
    return
  fi

  printf ${rowfmt} ${role} ${containers_color} ${#containers[@]} ${txtgrn} n/a ${txtgrn} n/a n/a
}

# Print the status of a pre/post flight role
function status_task() {
  local role="${1}"
  local container=$(docker ps -q -a --filter label=role=${role} | head -n1)
  if [[ -z "${container}" ]]; then
    if [[ -n "${SILENT}" ]]; then
      exit 1
    fi
    printf ${rowfmt} ${role} ${bldred} 0 ${txtgrn} n/a ${txtgrn} n/a n/a
    return
  fi
  local color
  local process_state=$(docker inspect --format '{{.State.Status}}' ${container})
  # valid states: paused restarting running dead created exited

  if [[ -n "${SILENT}" ]]; then
    if [[ "${process_state}" != "exited" ]]; then
      exit 1
    fi
    return
  fi

  case ${process_state} in
    exited)             color=${bldgrn};;
    running|created)    color=${bldpur};;
    *)                  color=${bldred};;
  esac
  mem_used=$(mem_used_from_container ${container})
  printf ${rowfmt} ${role} ${txtgrn} 1 ${txtgrn} n/a ${color} ${process_state} ${mem_used}
}

# Print pre-flight roles
for role in $(list_roles_by_flight_stage pre-flight | sort); do
  status_task ${role}
done

# Find all flight roles, and separate by bosh/docker (sorted)
bosh_roles=""
docker_roles=""
for role in $(list_roles_by_flight_stage flight | sort); do
  if [[ "$(get_role_type ${role})" == docker ]]; then
    docker_roles="${docker_roles} ${role}"
  else
    bosh_roles="${bosh_roles} ${role}"
  fi
done
# Print bosh flight roles
for role in ${bosh_roles}; do
  status_job_bosh ${role}
done
# Print docker flight roles
for role in ${docker_roles}; do
  status_job_docker ${role}
done

# Print post-flight roles
for role in $(list_roles_by_flight_stage post-flight | sort); do
  status_task ${role}
done
